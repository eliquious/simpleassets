package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"text/template"

	flag "github.com/spf13/pflag"
)

var (
	pkg       = flag.StringP("package", "p", "main", "Package name")
	output    = flag.StringP("output", "o", "assets.go", "Output file")
	prefix    = flag.StringP("trim", "t", "", "Trim file prefix")
	omitWrite = flag.Bool("omit-write", false, "Disable write access (not generated)")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [flags] ASSETS [ASSETS ...] \n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.ErrHelp = fmt.Errorf("")
	flag.Parse()
	assets := flag.Args()
	logger := log.New(os.Stdout, "", log.Ldate|log.Ltime|log.Lmicroseconds)

	// Check output file
	if *output == "" {
		log.Fatal("invalid output file")
	}

	// Check for assets
	if len(assets) == 0 {
		log.Fatal("no assets provided")
	}

	// Create new template and parse
	tmpl := template.New("")
	tmpl = tmpl.Funcs(template.FuncMap{"StringsJoin": strings.Join})
	tmpl, err := tmpl.Parse(assetTemplate)
	if err != nil {
		log.Fatal(err)
	}

	// Execute template
	content := Content{
		PackageName: *pkg,
		Assets:      readAssets(logger, assets),
		OmitWrite:   *omitWrite,
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, content); err != nil {
		log.Fatal(err)
	}
	log.Println(fmt.Sprintf("Preformatted file size: %d", buf.Len()))

	// Open output file
	fh, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	defer fh.Close()

	// Format generated code into output file
	cmd := exec.Command("gofmt")
	cmd.Stdin = &buf
	cmd.Stdout = fh
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}

// Content represents the content stored in the template.
type Content struct {
	OmitWrite   bool
	PackageName string
	Assets      []Asset
}

// Asset represents file asset.
type Asset struct {
	AssetID   string
	Name      string
	FileParts []string
}

func readAssets(logger *log.Logger, files []string) []Asset {
	var index int
	var fileparts []Asset
	for _, glob := range files {
		matches, err := filepath.Glob(glob)
		if err != nil {
			log.Fatal(err)
		}

		for _, file := range matches {

			// Skip directories
			stat, err := os.Stat(file)
			if stat.IsDir() {
				continue
			} else if err != nil {
				log.Fatal(err)
			}

			// logger.Println(file)
			parts, err := readParts(logger, file)
			if err != nil {
				log.Fatal(err)
			}
			logger.Println(fmt.Sprintf("File: %s, Parts: %d", file, len(parts)))

			fileparts = append(fileparts, Asset{
				AssetID:   fmt.Sprintf("asset%04d", index),
				Name:      strings.TrimPrefix(file, *prefix),
				FileParts: parts,
			})
			index++
		}
	}
	if index == 0 {
		logger.Fatal("no assets found")
	}
	return fileparts
}

func readParts(logger *log.Logger, filename string) ([]string, error) {

	// Open file
	fh, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer fh.Close()

	// Read file
	content, err := ioutil.ReadAll(fh)
	if err != nil {
		return nil, err
	}

	// Compress file
	var buf bytes.Buffer
	writer := gzip.NewWriter(&buf)
	writer.Write(content)
	writer.Flush()
	writer.Close()

	// Read parts
	var parts []string
	data := make([]byte, 80)
	partReader := strings.NewReader(base64.StdEncoding.EncodeToString(buf.Bytes()))
	for {
		n, err := partReader.Read(data)
		if n > 0 {
			parts = append(parts, string(data[:n]))
		} else if n == 0 || err == io.EOF {
			break
		} else {
			return nil, err
		}
	}
	return parts, nil
}

var assetTemplate = `// Code generated by simpleassets DO NOT EDIT.
package {{.PackageName}}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"strings"
)

// Asset stores the file data.
type Asset struct {
	Name 	   string
	Compressed bool
	Data       string
}

// Stored assets by filename
var assets = map[string]Asset{}

// ReadAsset reads an asset from the store.
func ReadAsset(name string) ([]byte, error) {

	// Get asset from map and verify
	asset, ok := assets[name]
	if !ok {
		return nil, fmt.Errorf("asset does not exist: %s", name)
	}

	// Decode base64
	decoded, err := base64.StdEncoding.DecodeString(asset.Data)
	if err != nil {
		return nil, err
	}

	// Decompress if required
	if asset.Compressed {
		reader, err := gzip.NewReader(bytes.NewReader(decoded))
		if err != nil {
			return nil, err
		}
		return ioutil.ReadAll(reader)
	}
	return decoded, nil
}
{{ if not .OmitWrite}}
// WriteAsset writes an asset to the store.
func WriteAsset(name string, data []byte) {
	encoded := base64.StdEncoding.EncodeToString([]byte(data))

	// Add to list of asset names if needed
	if _, ok := assets[name]; !ok {
		assetNames = append(assetNames, name)
	}

	// Store assset
	assets[name] = Asset{Name: name, Compressed: false, Data: encoded}
}{{end}}

// List of asset names
var assetNames = []string{ {{ range $index, $element := .Assets}}
	"{{$element.Name}}",{{end}}
}

// ListAssetNames returns the list of asset names
func ListAssetNames() []string {
	return assetNames
}

func init() { {{ range $index, $element := .Assets}}
	assets["{{$element.Name}}"] = Asset{ Name: "{{$element.Name}}", Compressed: true, Data: {{$element.AssetID}}} {{end}}
}
{{ range $index, $element := .Assets}}
var {{$element.AssetID}} = strings.Join([]string{ {{ range $partindex, $part := $element.FileParts }}
	"{{$part}}",{{end}}
}, "")
{{end}}
`
